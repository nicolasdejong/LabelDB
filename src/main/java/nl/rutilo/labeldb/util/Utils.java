package nl.rutilo.labeldb.util;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Stream;

public class Utils {
    private Utils() {}
    public static final Charset TEXT_ENCODING = StandardCharsets.UTF_8;

    /**
     * Map name to (possibly case-insensitive) filesystem name, replacing
     * characters that are not allowed, while preventing collisions with
     * similar names. Adds prefix to prevent names that are not allowed
     * in a filesystem, like com1, con or /dev/null.
     *
     * This function attempts to keep the name somewhat readable.
     * This transformation can be transformed back to the original name.
     *
     * chars not allowed in windows: < (lt) > (gt) : " / \ | ? * (ascii < 32)
     * linux allows much more, except just '/'.
     *
     * Algorithm:
     *  - 'name_' prefix
     *  - a-z, 0-9, and each one of "_,=- " are used as-is
     *  - A-Z are set to lowercase and a ^ prefix added
     *  - all other characters are changed to their hex ascii value as %(hex)
     */
    public static String nameToFilename(String name) {
        final StringBuilder sb = new StringBuilder();
        for(final char c : (name == null ? "" : name).toCharArray()) {
            if((c >= 'a' && c <= 'z') || "0123456789_,=- ".indexOf(c) >= 0) {
                sb.append(c);
            } else
            if(c >= 'A' && c <= 'Z') {
                sb.append("^" + Character.toLowerCase(c));
            } else {
                sb.append("%(");
                sb.append(Integer.toHexString(c));
                sb.append(")");
            }
        }
        return "name_" + sb.toString();
    }

    /** Transforms the given name as generated by nameToFilename() to the original name */
    public static String filenameToName(String filename) {
        final StringBuilder sb = new StringBuilder();
        int code = -1;
        boolean upper = false;
        for(final char c : filename.replaceFirst("^name_", "").toCharArray()) {
            if(code >= 0) {
                if(c == ')') { sb.append((char)code); code = -1; } else
                if(c != '(') code = code * 16 + Integer.parseInt("" + c, 16);
            } else
            if(c == '%') code = 0;
            else
            if(upper) { upper = false; sb.append(Character.toUpperCase(c)); }
            else
            if(c == '^') upper = true;
            else
                sb.append(c);
        }
        return sb.toString();
    }

    /**
     * Alternative for Object.wait(int) that rethrows InterruptedException as
     * a runtime exception and is unit-tested here. Result is a function call
     * that does not require a catch() and needs no extra work to unit-test
     * the interrupt() on the wait.<p>
     *
     * This call will do the synchronized(obj) so that is not required.
     */
    public static void waitOn(Object obj, int timeout) {
        //noinspection SynchronizationOnLocalVariableOrMethodParameter
        synchronized(obj) {
            try {
                obj.wait(timeout);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    //<editor-fold desc="Temporary files & dirs">

    /** Maximum loop count when creating temp directories. */
    private static final int TEMP_DIR_ATTEMPTS = 10_000;

    /** Copied from Guava
     *
     * <p>Atomically creates a new directory somewhere beneath the system's
     * temporary directory (as defined by the {@code java.io.tmpdir} system
     * property), and returns its name.
     *
     * <p>Use this method instead of {@link File#createTempFile(String, String)}
     * when you wish to create a directory, not a regular file.  A common pitfall
     * is to call {@code createTempFile}, delete the file and create a
     * directory in its place, but this leads a race condition which can be
     * exploited to create security vulnerabilities, especially when executable
     * files are to be written into the directory.
     *
     * <p>This method assumes that the temporary volume is writable, has free
     * inodes and free blocks, and that it will not be called thousands of times
     * per second.
     *
     * @return the newly-created directory
     * @throws IllegalStateException if the directory could not be created
     */
    public static File createTempDir() {
        File baseDir = new File(System.getProperty("java.io.tmpdir"));
        String baseName = System.currentTimeMillis() + "-";

        for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {
            File tempDir = new File(baseDir, baseName + counter);
            if (tempDir.mkdir()) {
                return tempDir;
            }
        }
        throw new IllegalStateException("Failed to create directory within "
            + TEMP_DIR_ATTEMPTS + " attempts (tried "
            + baseName + "0 to " + baseName + (TEMP_DIR_ATTEMPTS - 1) + ')');
    }
    //</editor-fold>

    //<editor-fold desc="Read & Write">
    public static Optional<byte[]> toByteArray(InputStream in) {
        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        return copy(in, bos).map(b -> bos.toByteArray());
    }
    public static Optional<OutputStream> copy(InputStream in, OutputStream out) {
        if(in == null || out == null) return Optional.empty();
        try {
            int val;
            while ((val = in.read()) != -1) out.write(val);
        } catch(final IOException e) {
            return Optional.empty();
        }
        return Optional.of(out);
    }

    public static Optional<byte[]> readFileToByteArray(File file) {
        try {
            return Optional.of(Files.readAllBytes(file.toPath()));
        } catch (final IOException ignored) {
            return Optional.empty();
        }
    }

    /** Use this instead of File.write when IOException should be wrapped in a RuntimeException */
    public static void writeByteArrayToFile(File target, byte[] data) {
        try {
            Files.write(target.toPath(), data);
        } catch(final IOException cause) {
            throw new RuntimeException("Unable to write to file", cause);
        }
    }
    /** Use this instead of File.writeString when IOException should be wrapped in a RuntimeException */
    public static void writeStringToFile(File target, String data) {
        writeByteArrayToFile(target, data.getBytes(TEXT_ENCODING));
    }
    public static Optional<String> fileToString(File file) {
        return readFileToByteArray(file).map(bytes -> new String(bytes, TEXT_ENCODING));
    }
    //</editor-fold>

    public static void deleteDirectory(File dir) {
        if (!dir.exists()) return; // nothing left to do

        // This method was split in two because the walk()
        // method only seems to throw if dir does not exist.
        // To get a test coverage of 100% it should throw,
        // so a call with a non-existent directory is needed.
        deleteDirectoryImpl(dir);
    }
    protected static void deleteDirectoryImpl(File dir) {
        try {
            Files.walk(dir.toPath())
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(File::delete);
        } catch (final IOException cause) {
            // walk() will not throw because dir exists().
            // Still added because the language requires it.
            throw new RuntimeException(cause);
        }
    }

    public static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (final InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    @SafeVarargs public static <T> T or(T... nullables) {
        return or(Objects::nonNull, nullables).orElseThrow(NullPointerException::new);
    }
    @SafeVarargs public static <T> Optional<T> or(Predicate<T> accept, T... values) {
        return Stream.of(values).filter(v -> accept != null && accept.test(v)).findFirst();
    }
}
